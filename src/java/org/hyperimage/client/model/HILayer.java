/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at license/HYPERIMAGE.LICENSE
 * or http://www.sun.com/cddl/cddl.html.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at license/HYPERIMAGE.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2006-2009 Humboldt-Universitaet zu Berlin
 * All rights reserved.  Use is subject to license terms.
 */

/*
 * Copyright 2014 Leuphana Universität Lüneburg
 * All rights reserved.  Use is subject to license terms.
 */

package org.hyperimage.client.model;

import java.awt.Color;
import java.util.Vector;

import org.hyperimage.client.ws.HiLayer;

/**
 * 
 * Class: HILayer
 * Package: org.hyperimage.client.model
 * @author Jens-Martin Loebel
 *
 * Wrapper class for HiLayer class generated by WSImport
 * Provides additional functionality and syncs changes to Client Model (HiLayer)
 */
public class HILayer {
	
	private Vector<RelativePolygon> polygons = new Vector<RelativePolygon>();
	private Color layerColour;
	private HiLayer model;
	private int scaleX, scaleY;

	public HILayer(HiLayer model, int scaleX, int scaleY) {
		this.model = model;
		this.scaleX = scaleX;
		this.scaleY = scaleY;
		this.layerColour = new Color(model.getRed(), 
				model.getGreen(),
				model.getBlue(),
				(int)(model.getOpacity()*255));

		// split model polygon string into separate polygons
		if ( model.getPolygons().length() > 0 ) {
			for (String polygon : model.getPolygons().split("\\|"))
				polygons.addElement(new RelativePolygon(polygon, scaleX, scaleY));
		}
	}

	public void setScale(int scaleX, int scaleY) {
		this.scaleX = scaleX;
		this.scaleY = scaleY;
		for (RelativePolygon polygon : polygons)
			polygon.setScale(scaleX, scaleY);
	}

	public Color getColour() {
		return this.layerColour;
	}
	
	public Color getSolidColour() {
		return new Color (layerColour.getRed(), layerColour.getGreen(), layerColour.getBlue());
	}

	public boolean hasChanges() {
		if ( layerColour.getRed() != model.getRed() ||
			 layerColour.getGreen() != model.getGreen() ||
			 layerColour.getBlue() != model.getBlue() ||
			 ((float)layerColour.getAlpha()/255f) != model.getOpacity() )
			return true;
		else return false;
	}
	
	public boolean hasPolygonChanges() {
		if ( model.getPolygons().compareTo(serializePolygons()) != 0 )
			return true;
		return false;
	}
	
	public void resetChanges() {
		this.layerColour = new Color(model.getRed(), 
				model.getGreen(),
				model.getBlue(),
				(int)(model.getOpacity()*255));
	}

	public void syncChanges() {
		model.setRed(layerColour.getRed());
		model.setGreen(layerColour.getGreen());
		model.setBlue(layerColour.getBlue());
		model.setOpacity(((float)layerColour.getAlpha())/255f);
	}
	
	public void resetPolygonChanges() {
		// split model polygon string into separate polygons
		polygons.removeAllElements();
		if ( model.getPolygons().length() > 0 ) {
			for (String polygon : model.getPolygons().split("\\|"))
				polygons.addElement(new RelativePolygon(polygon, scaleX, scaleY));
		}		
	}
	
	private String serializePolygons() {
		// sync polygons
		String polygonString = null;
		if ( polygons.size() > 0 ) {
			for ( RelativePolygon polygon : polygons ) {
				polygon.commitChangesToModel();
				String polygonModel = polygon.getModel();
				// discard empty or single point polygons
				if ( polygonModel.split(";",2)[1].length() > 0  &&
					 polygonModel.split(";",2)[1].compareTo("0.0#0.0") != 0 ) {

					if ( polygonString != null ) 
						polygonString = polygonString + "|"+polygonModel;
					else 
						polygonString = polygonModel;

				}
			}
		}
		if ( polygonString == null ) polygonString = "";
		return polygonString;
	}
	
	public void syncPolygonChanges() {
		model.setPolygons(serializePolygons());
	}

	
	public void setColour(Color layerColour) {
		this.layerColour = new Color (layerColour.getRed(), layerColour.getGreen(), layerColour.getBlue(), this.layerColour.getAlpha());
	}

	public void setOpacity(int opacity) {
		this.layerColour = new Color(this.layerColour.getRed(), this.layerColour.getGreen(), this.layerColour.getBlue(), opacity);
	}
	
	public int getOpacity() {
		return this.layerColour.getAlpha();
	}

	public void setOpacity(float relOpacity) {
		int opacity = (int)relOpacity*255;
		this.layerColour = new Color(this.layerColour.getRed(), this.layerColour.getGreen(), this.layerColour.getBlue(), opacity);
	}

	public Vector<RelativePolygon> getRelativePolygons() {
		return this.polygons;
	}
	
	public HiLayer getModel() {
		return this.model;
	}

}
